# Πρασσάς Αντώνιος 5247
#1o##############################################
if [ $# -eq 0 ]									# εδω χρησιμοποιοώ το $# το οποίο μετράει όλα τα ορίσματα που έχουν δωθεί στην
     then echo 5247;							# γραμμή εντολών (το $0 που ειναι το προγραμμα μας δεν μετραει) και αν ειναι ίσο με το 0 
  exit;											# μπαινει στην συνθηκη
   fi											#
#2o##############################################	
 if [[ $# -eq 2 ]]								# εδω παλι το ίδιο και επειδη ειναι η μοναδικη περιπτωση που εχει 2 ορίσματα το κανουμε 
 then 											# με το $#.δεν θα ηταν συνετο να βάλουμε συνθήκη μονο με το -f σαν πρωτο όρισμα καθώς το βάζουμε
 files=$2;										#και σε αλλες εντολές και θα έμπαινε στην συνθήκη κάθε φορά. για να μην εμφανίζονται τα σχολια 
 awk -F "|" '/^[^#]/ {print $0}' $files			#στην awk βαζουμε σαν regexp το ^[^#] γτ στο αρχείο μας όλα τα σχόλια μας ξεκινούν με την #
      fi										#
#3o#######################################################################################################################################################
 if [[ $3 = "-id" && $1 = "-f" ]]				#η awk ελεγχει γραμμή γραμμή το αρχείο οπότε λεμε ότι όταν βρει στην 1η στήλη το user id που έχω δώσει
 then											# να εκτευπωσει τα αναλογα πεδία εδω δεν χρειαζεται το regexp για τα σχολια 
 filep=$2;										###########
  awk -F "|" -v uid=$4  '/^[^#]/ && (uid==$1){print $2,$3,$5 }' $filep;#
	elif [[ $1 = "-id" && $3 = "-f" ]]					  # 	
		then 											  #	
		filep=$4;										  #######
	     awk -F'|' -v uid=$2  'uid==$1{print $2,$3,$5 }' $filep;#
	fi															#
#4o ######################################################################################################
if [[ $1 = "--firstnames" && $2 = "-f" ]]                                 # εδω παρομοια με πριν αν στην γραμμη εντολων διαβασει firstnames	
   then                                                                   # θα εκτυπώσει την στήλη με τα μικρα ονοματα και εδω χρειαζόμαστε  
     files=$3;                                                            #να μην εκτυπωνει τα σχολια γτ στην ουσια εκτυπώνουμε μια ολόκληρη
    awk -F "|" '/^[^#]/ {print $2}' $files | sort -f | uniq;	              #στήλη.επειδη δεν κατανοησα πληρως την εκφωνηση για το να ειναι διακριτα
elif [[ $1 = "-f" && $3 = "--firstnames" ]]								  #τα ονοματα (να εμφανιζονται μονο μια φορα;) εβαλα την uniq η οποια εντολη
   then																	  #εμφανιζει μονο μια φορα το καθε string οσες φορες και να υπάρχει. 
   files=$2																  #
awk -F "|" '/^[^#]/ {print $2}' $files | sort -f | uniq;
  fi																	  #	
#5o	#######################################################################
if [[ $1 = "--lastnames" && $2 = "-f" ]]								  #
   then 																  #
     files=$3;															  #
    awk -F "|" '/^[^#]/ {print $3}' $files | sort -f | uniq;			  #
             															  #
elif [[ $1 = "-f" && $3 = "--lastnames" ]]								  #	
   then																	  #
   files=$2;														      #											
awk -F "|" '/^[^#]/ {print $3}' $files | sort -f | uniq;				  #
   fi																	  #
#6o ########################################################################################################################
	
if [[ $1 = "--born-since" && $3 = "-f" && $5 = "" ]]
	then 
	files=$4;                                                          # εδω παρομοια με τα υπολοιπα με μονη διαφορα οτι εχουμε ενσωματώσει μια
	awk -F "|" -v dates=$2 '/^[^#]/ && ( dates <= $5 ) {print $0}' $files | sort -f | uniq;		#συνθήκη σύγκρισης με το αναλογοπεδίο 
elif [[ $1 = "-f" && $3 = "--born-since" && $5 = "" ]]
	then 
	files=$2;
	awk -F "|" -v dates=$4 '/^[^#]/ && ( dates <= $5 ) {print $0}' $files | sort -f | uniq;
	fi	

if [[ $1 = "--born-until" && $3 = "-f" && $5 = "" ]]
	then
	files=$4;
	awk -F "|" -v dated=$2 '/^[^#]/ && ( dated >= $5 ) {print $0}' $files | sort -f | uniq;
elif [[ $1 = "-f" && $3 = "--born-until" && $5 = "" ]]
	then 
	files=$2;
	awk -F "|" -v dated=$4 '/^[^#]/ && ( dated >= $5 ) {print $0}' $files | sort -f | uniq;
fi	
	#############################################################################
if 	[[ $1 = "--born-since" && $3 = "-f" && $5 = "--born-until" ]]
	then
	files=$4;
	awk -F"|" -v dates=$2 -v dateu=$6 '/^[^#]/ && ( dates <= $5 ) && ( dateu >= $5 ) {print $0}' $files | sort -f | uniq;
 elif [[ $1 = "--born-since" && $3 = "--born-until" && $5 = "-f" ]]
	then
	files=$6
	awk -F"|" -v dates=$2 -v dateu=$4 '/^[^#]/ && ( dates <= $5 ) && ( dateu >= $5 ) {print $0}' $files | sort -f | uniq;
 elif [[ $1 = "-f" && $3 = "--born-until" && $5 = "--born-since" ]]	
	then 
	files=$2;
	awk -F"|" -v dates=$6 -v dateu=$4 '/^[^#]/ && ( dates <= $5 ) && ( dateu >= $5 ) {print $0}' $files | sort -f | uniq;
elif [[ $1 = "-f" && $3 = "--born-since" && $5 = "--born-until" ]]
	then
	files=$2;
	awk -F"|" -v dates=$4 -v dateu=$6 '/^[^#]/ && ( dates <= $5 ) && ( dateu >= $5 ) {print $0}' $files | sort -f | uniq;
elif [[ $1 = "--born-until" && $3 = "--born-since" && $5 = "-f" ]]
	then 
	files=$6;
	awk -F"|" -v dates=$4 -v dateu=$2 '/^[^#]/ && ( dates <= $5 ) && ( dateu >= $5 ) {print $0}' $files | sort -f | uniq;
elif [[ $1 = "--born-until" && $3 = "-f" && $5 = "--born-since" ]]
	then
	files=$4;
	awk -F"|" -v dates=$6 -v dateu=$2 '/^[^#]/ && ( dates <= $5 ) && ( dateu >= $5 ) {print $0}' $files | sort -f | uniq;
fi	
#7o #######################################################	
	
if [ $1 = "--browsers" ] 										#εδω για μετρήσουμε τους browsers χρησιμοποιω ενα option της uniq το -c 
	then 														#η οποια μετράει ποσες φορές βρισκει το καθε string. αυτο ειναι απλο αλλα
	files=$3;													#μονο με την uniq η έξοδος δεν ειναι η επιθημητη γτ αρχιζει και εκτυπωνει
	awk -F "|" '/^[^#]/ {print $8}' $files | sort | uniq -c	    #κατεβατα π.χ. 2 chrome 1 firefox 3 opera.... και οχι συνολικα οπως το θελουμε
elif [[ $3 = "--browsers" ]]									#οποτε μια λυση με την συγκεκριμενη υλοποιηση ειναι να γινει sort και μετα
	then 														#να μετρήσουμε για να βγει η επιθυμητη εξοδος.εδω παλι πρεπει να αγνοησουμε τα σχολια
	files=$2;
awk -F "|" '/^[^#]/ {print $8}' $files | sort | uniq -c
fi	
#8ο ##########################################################	
if [[ $1 = "-f" && $3 = "--edit" && $5 > 1 && $5 < 9 ]]       # εδω το ερωτημα ειναι πολυ απλο και συνολικα βρηκα υλοποιησεις αλλα μονο αυτη μου δουλεψε
then														#καθώς δεν μπορεσα να κανω την sed να δουλεψει με μεταβλητες...στη συγκεκριμενη υλοποιηση 				
	files=$2;												#αλλάζω το περιεχόμενο της στηλης με συνθηκη να μην αλλαζει το user id και να μην παιρνει παραπανω
	awk -F "|" -v column=$5 -v uid=$4 -v val=$6 ' uid == $1{ $column = val; }1' OFS="|" $files > tmp; #απο 8 ορίσματα και γράφω την αλλαγη σε ενα temp αρχείο 
	mv tmp $2; 																		#και μετα στο κανονικο μιας και η awk δεν αποθηκευε την αλλαγη κατευθειαν 	
	echo 1														#στο αρχείο εκτως απο την περιπτωση που αν βαλουμε >> file η awk γραφει στο τελευταιο line του				
elif [[ $1 = "--edit" && $5 = "-f" && $3 > 1 && $3 < 9 ]]	 #του αρχείου και μετα με την sed να βρουμε το πρωτο occurence του user id στο αρχείο και να το διαγραψουμε
	then														#καθως ξέρουμε πως το ανανεωμένο πεδίο βρίσκεται στην τελευταία γραμμή του αρχείου αλλα no sed no game!!
	files=$6;													#και θα ήθελα πολυ να δω το συγκεκριμενο ερωτημα να το δω υλοποιημνεο με sed.
	awk -F "|" -v column=$3 -v uid=$2 -v val=$4 ' uid == $1{ $column = val; }1' OFS="|" $files > tmp
	mv tmp $files
echo 2 
fi
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	


